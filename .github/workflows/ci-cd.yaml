name: ci-cd

on:
  workflow_dispatch:

env:
  PYTHON_VERSION: "3.11"
  MLFLOW_TRACKING_URI: "file:./mlruns"
  MLFLOW_EXPERIMENT_NAME: "tabular-classification"
  ACCURACY_THRESHOLD: "0.90"

jobs:
  test-train-validate:
    runs-on: ubuntu-latest

    env:
      MLFLOW_TRACKING_URI: "file:./mlruns"
      MLFLOW_EXPERIMENT_NAME: "cmapss_rul_xgb_optuna"


    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # API/runtime deps (FastAPI, Uvicorn, etc.)
          if [ -f requirements-api.txt ]; then pip install -r requirements-api.txt; fi
          pip install pytest

      - name: Add src to PYTHONPATH
        run: echo "PYTHONPATH=$PWD/src" >> $GITHUB_ENV

      - name: Debug repo tree
        run: |
          pwd
          ls -la
          ls -la src || true
          ls -la src/api || true

      - name: Run unit tests (PyTest)
        run: pytest -q

      - name: Run DVC pipeline (train + evaluate)
        run: dvc repro

      - name: Enforce quality gate
        env:
          MLFLOW_TRACKING_URI: "file:./mlruns"
          MLFLOW_EXPERIMENT_NAME: "cmapss_rul_xgb_optuna"
          METRIC_NAME: "r2"
          METRIC_MODE: "max"
          ACCURACY_THRESHOLD: "0.90"
        run: python .github/scripts/check_accuracy_gate.py


  deploy:
    needs: test-train-validate
    runs-on: [self-hosted, minikube]
    if: needs.test-train-validate.result == 'success'

    env:
      IMAGE_TAG: ${{ github.sha }}
      IMAGE_REPO: ${{ secrets.DOCKER_IMAGE_REPO }} 

    defaults:
      run:
        shell: powershell

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Debug DockerFile presence
        shell: powershell
        run: |
          Get-Location
          Get-ChildItem -Force
          if (Test-Path infra) { Get-ChildItem -Force infra }
          if (Test-Path infra/docker) { Get-ChildItem -Force infra/docker }
          if (!(Test-Path infra/docker/DockerFile)) { throw "DockerFile not found at infra/docker/DockerFile" }

      - name: Build and push image
        id: build
        run: |
          $IMAGE = "${{ env.IMAGE_REPO }}:${{ env.IMAGE_TAG }}"
          docker build -f infra/docker/DockerFile -t $IMAGE .
          docker push $IMAGE
          Add-Content -Path $env:GITHUB_OUTPUT -Value "image=$IMAGE"

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.30.0"

      - name: Ensure minikube is running (and wait)
        shell: powershell
        run: |
          minikube start --driver=docker
          minikube status
          minikube update-context

          # Wait until apiserver is ready
          $ok = $false
          for ($i=0; $i -lt 30; $i++) {
            try {
              kubectl get --raw='/readyz' | Out-Host
              $ok = $true
              break
            } catch {
              Start-Sleep -Seconds 2
            }
          }
          if (-not $ok) { throw "Minikube apiserver not ready" }

      - name: Verify kubectl context
        run: |
          kubectl config current-context
          kubectl get ns

      - name: Deploy new version to Kubernetes
        run: |
          $IMAGE = "${{ steps.build.outputs.image }}"
          kubectl set image deployment/predictive-maintenance-api "api=$IMAGE"
          kubectl rollout status deployment/predictive-maintenance-api --timeout=180s
