name: ci-cd

on:
  workflow_dispatch:

env:
  PYTHON_VERSION: "3.11"
  MLFLOW_TRACKING_URI: "file:./mlruns"
  MLFLOW_EXPERIMENT_NAME: "tabular-classification"
  ACCURACY_THRESHOLD: "0.90"

jobs:
  test-train-validate:
    runs-on: ubuntu-latest
    env:
      MLFLOW_TRACKING_URI: "file:./mlruns"
      MLFLOW_EXPERIMENT_NAME: "cmapss_rul_xgb_optuna"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # API/runtime deps (FastAPI, Uvicorn, etc.)
          if [ -f requirements-api.txt ]; then pip install -r requirements-api.txt; fi
          pip install pytest

      - name: Add src to PYTHONPATH
        run: echo "PYTHONPATH=$PWD/src" >> $GITHUB_ENV

      - name: Debug repo tree
        run: |
          pwd
          ls -la
          ls -la src || true
          ls -la src/api || true

      - name: Run unit tests (PyTest)
        run: pytest -q

      - name: Run DVC pipeline (train + evaluate)
        run: dvc repro

      # NEW: ensure the model exists where the Docker build expects it
      - name: Verify model artifact exists
        run: |
          ls -la models || true
          test -f models/bestmodel.joblib

      # NEW: upload the trained model so deploy job can include it in the image
      - name: Upload model artifact for deploy
        uses: actions/upload-artifact@v4
        with:
          name: model-artifact
          path: models/bestmodel.joblib
          if-no-files-found: error

      - name: Enforce quality gate
        env:
          MLFLOW_TRACKING_URI: "file:./mlruns"
          MLFLOW_EXPERIMENT_NAME: "cmapss_rul_xgb_optuna"
          METRIC_NAME: "r2"
          METRIC_MODE: "max"
          ACCURACY_THRESHOLD: "0.90"
        run: python .github/scripts/check_accuracy_gate.py

  deploy:
    needs: test-train-validate
    runs-on: [self-hosted, minikube]
    if: needs.test-train-validate.result == 'success'
    env:
      IMAGE_TAG: ${{ github.sha }}
      IMAGE_REPO: ${{ secrets.DOCKER_IMAGE_REPO }}

    defaults:
      run:
        shell: powershell

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # NEW: download model built in the previous job
      - name: Download model artifact
        uses: actions/download-artifact@v4
        with:
          name: model-artifact
          path: .github_artifacts

      # NEW: place model in the Docker build context at models/bestmodel.joblib
      - name: Place model into Docker build context
        run: |
          New-Item -ItemType Directory -Force models | Out-Null

          $candidate1 = ".github_artifacts/models/bestmodel.joblib"
          $candidate2 = ".github_artifacts/bestmodel.joblib"

          if (Test-Path $candidate1) {
            Copy-Item -Force $candidate1 "models/bestmodel.joblib"
          } elseif (Test-Path $candidate2) {
            Copy-Item -Force $candidate2 "models/bestmodel.joblib"
          } else {
            Write-Host "Downloaded artifact contents:"
            Get-ChildItem -Recurse -Force .github_artifacts | Out-Host
            throw "Model file not found in downloaded artifact."
          }

          if (!(Test-Path "models/bestmodel.joblib")) { throw "Model file missing in build context." }

      - name: Log in to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Debug DockerFile presence
        run: |
          Get-Location
          Get-ChildItem -Force
          if (Test-Path infra) { Get-ChildItem -Force infra }
          if (Test-Path infra/docker) { Get-ChildItem -Force infra/docker }
          if (!(Test-Path infra/docker/DockerFile)) { throw "DockerFile not found at infra/docker/DockerFile" }

      - name: Build and push image
        id: build
        run: |
          $IMAGE = "${{ env.IMAGE_REPO }}:${{ env.IMAGE_TAG }}"
          docker build -f infra/docker/DockerFile -t $IMAGE .
          docker push $IMAGE
          Add-Content -Path $env:GITHUB_OUTPUT -Value "image=$IMAGE"

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.30.0"

      - name: Ensure minikube is running (and wait)
        run: |
          minikube start --driver=docker
          minikube status
          minikube update-context

          # Wait until apiserver is ready
          $ok = $false
          for ($i = 0; $i -lt 30; $i++) {
            try {
              kubectl get --raw='/readyz' | Out-Host
              $ok = $true
              break
            } catch {
              Start-Sleep -Seconds 2
            }
          }
          if (-not $ok) { throw "Minikube apiserver not ready" }

      - name: Verify kubectl context
        run: |
          kubectl config current-context
          kubectl get ns

      - name: Deploy new version to Kubernetes
        run: |
          $IMAGE = "${{ steps.build.outputs.image }}"
          kubectl set image deployment/predictive-maintenance-api "api=$IMAGE"
          kubectl rollout status deployment/predictive-maintenance-api --timeout=600s

      # NEW: if rollout fails, dump useful diagnostics (doesn't change behavior otherwise)
      - name: Debug rollout failure
        if: failure()
        run: |
          kubectl get deploy predictive-maintenance-api -o wide
          kubectl describe deploy predictive-maintenance-api
          kubectl get rs -l app=predictive-maintenance-api -o wide
          kubectl get pods -l app=predictive-maintenance-api -o wide
          kubectl describe pods -l app=predictive-maintenance-api
          kubectl logs -l app=predictive-maintenance-api --all-containers=true --tail=200
